/*
Copyright (c) 2019 Daybrush
name: @scena/react-ruler
license: MIT
author: Daybrush
repository: https://github.com/daybrush/ruler/blob/master/packages/react-ruler
version: 0.14.2
*/
import { version, createElement, PureComponent } from 'react';
import { ref } from 'framework-utils';
import { convertUnitSize } from '@daybrush/utils';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var Ruler =
/*#__PURE__*/
function (_super) {
  __extends(Ruler, _super);

  function Ruler() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      scrollPos: 0
    };
    _this.width = 0;
    _this.height = 0;
    _this._zoom = 0;
    _this._rulerScale = 0;
    _this._observer = null;

    _this._checkResize = function () {
      _this.resize();
    };

    return _this;
  }

  var __proto = Ruler.prototype;

  __proto.render = function () {
    var props = this.props;
    var portalContainer = props.portalContainer;
    var portalAttributes = {};

    if ((version || "").indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer: portalContainer
      };
    }

    this._zoom = props.zoom;
    return createElement("canvas", __assign({
      ref: ref(this, "canvasElement")
    }, portalAttributes, {
      style: this.props.style
    }));
  };

  __proto.componentDidMount = function () {
    var canvas = this.canvasElement;
    var context = canvas.getContext("2d", {
      alpha: false
    });
    this.canvasContext = context;

    if (this.props.useResizeObserver) {
      this._observer = new ResizeObserver(this._checkResize);

      this._observer.observe(canvas, {
        box: "border-box"
      });
    } else {
      this.resize();
    }
  };

  __proto.componentDidUpdate = function () {
    this.resize();
  };

  __proto.componentWillUnmount = function () {
    var _a;

    this.state.scrollPos = 0;
    (_a = this._observer) === null || _a === void 0 ? void 0 : _a.disconnect();
  };
  /**
   * Gets the scroll position of the ruler.
   */


  __proto.getScrollPos = function () {
    return this.state.scrollPos;
  };
  /**
   * @method Ruler#scroll
   * @param scrollPos
   */


  __proto.scroll = function (scrollPos, nextZoom) {
    this.draw(scrollPos, nextZoom);
  };
  /**
   * @method Ruler#resize
   */


  __proto.resize = function (nextZoom) {
    var canvas = this.canvasElement;
    var _a = this.props,
        width = _a.width,
        height = _a.height,
        scrollPos = _a.scrollPos;

    var rulerScale = this._getRulerScale();

    this.width = width || canvas.offsetWidth;
    this.height = height || canvas.offsetHeight;
    canvas.width = this.width * rulerScale;
    canvas.height = this.height * rulerScale;
    this.draw(scrollPos, nextZoom);
  };

  __proto.draw = function (scrollPos, nextZoom) {
    if (scrollPos === void 0) {
      scrollPos = this.state.scrollPos;
    }

    if (nextZoom === void 0) {
      nextZoom = this._zoom;
    }

    this._zoom = nextZoom;
    var props = this.props;
    var _a = props,
        unit = _a.unit,
        type = _a.type,
        backgroundColor = _a.backgroundColor,
        lineColor = _a.lineColor,
        textColor = _a.textColor,
        textBackgroundColor = _a.textBackgroundColor,
        direction = _a.direction,
        _b = _a.negativeRuler,
        negativeRuler = _b === void 0 ? true : _b,
        _c = _a.segment,
        segment = _c === void 0 ? 10 : _c,
        textFormat = _a.textFormat,
        _d = _a.range,
        range = _d === void 0 ? [-Infinity, Infinity] : _d,
        rangeBackgroundColor = _a.rangeBackgroundColor,
        selectedRanges = _a.selectedRanges,
        selectedBackgroundColor = _a.selectedBackgroundColor,
        _e = _a.lineWidth,
        lineWidth = _e === void 0 ? 1 : _e;

    var rulerScale = this._getRulerScale();

    var width = this.width;
    var height = this.height;
    var state = this.state;
    state.scrollPos = scrollPos;
    var context = this.canvasContext;
    var isHorizontal = type === "horizontal";
    var isNegative = negativeRuler !== false;
    var font = props.font || "10px sans-serif";
    var textAlign = props.textAlign || "left";
    var textOffset = props.textOffset || [0, 0];
    var containerSize = isHorizontal ? height : width;
    var mainLineSize = convertUnitSize("".concat(props.mainLineSize || "100%"), containerSize);
    var longLineSize = convertUnitSize("".concat(props.longLineSize || 10), containerSize);
    var shortLineSize = convertUnitSize("".concat(props.shortLineSize || 7), containerSize);
    var lineOffset = props.lineOffset || [0, 0];

    if (backgroundColor === "transparent") {
      // Clear existing paths & text
      context.clearRect(0, 0, width * rulerScale, height * rulerScale);
    } else {
      // Draw the background
      context.rect(0, 0, width * rulerScale, height * rulerScale);
      context.fillStyle = backgroundColor;
      context.fill();
    }

    context.save();
    context.scale(rulerScale, rulerScale);
    context.strokeStyle = lineColor;
    context.lineWidth = lineWidth;
    context.font = font;
    context.fillStyle = textColor;

    switch (direction) {
      case "start":
        context.textBaseline = "top";
        break;

      case "center":
        context.textBaseline = "middle";
        break;

      case "end":
        context.textBaseline = "bottom";
        break;
    }

    context.translate(0.5, 0);
    context.beginPath();
    var size = isHorizontal ? width : height;
    var zoomUnit = nextZoom * unit;
    var minRange = Math.floor(scrollPos * nextZoom / zoomUnit);
    var maxRange = Math.ceil((scrollPos * nextZoom + size) / zoomUnit);
    var length = maxRange - minRange;
    var alignOffset = Math.max(["left", "center", "right"].indexOf(textAlign) - 1, -1);
    var barSize = isHorizontal ? height : width; // Draw Selected Range Background

    if (selectedBackgroundColor !== "transparent" && (selectedRanges === null || selectedRanges === void 0 ? void 0 : selectedRanges.length)) {
      selectedRanges.forEach(function (selectedRange) {
        var rangeStart = Math.max(selectedRange[0], range[0], negativeRuler ? -Infinity : 0);
        var rangeEnd = Math.min(selectedRange[1], range[1]);
        var rangeX = (rangeStart - scrollPos) * nextZoom;
        var rangeWidth = (rangeEnd - rangeStart) * nextZoom;

        if (rangeWidth <= 0) {
          return;
        }

        context.save();
        context.fillStyle = selectedBackgroundColor;

        if (isHorizontal) {
          context.fillRect(rangeX, 0, rangeWidth, barSize);
        } else {
          context.fillRect(0, rangeX, barSize, rangeWidth);
        }

        context.restore();
      });
    } // Draw Range Background


    if (rangeBackgroundColor !== "transparent" && range[0] !== -Infinity && range[1] !== Infinity) {
      var rangeStart = (range[0] - scrollPos) * nextZoom;
      var rangeEnd = (range[1] - range[0]) * nextZoom;
      context.save();
      context.fillStyle = rangeBackgroundColor;

      if (isHorizontal) {
        context.fillRect(rangeStart, 0, rangeEnd, barSize);
      } else {
        context.fillRect(0, rangeStart, barSize, rangeEnd);
      }

      context.restore();
    } // Render Segments First


    for (var i = 0; i <= length; ++i) {
      var value = i + minRange;

      if (!isNegative && value < 0) {
        continue;
      }

      var startValue = value * unit;
      var startPos = (startValue - scrollPos) * nextZoom;

      for (var j = 0; j < segment; ++j) {
        var pos = startPos + j / segment * zoomUnit;
        var value_1 = startValue + j / segment * unit;

        if (pos < 0 || pos >= size || value_1 < range[0] || value_1 > range[1]) {
          continue;
        }

        var lineSize = j === 0 ? mainLineSize : j % 2 === 0 ? longLineSize : shortLineSize;
        var origin = 0;

        switch (direction) {
          case "start":
            origin = 0;
            break;

          case "center":
            origin = barSize / 2 - lineSize / 2;
            break;

          case "end":
            origin = barSize - lineSize;
            break;
        }

        var _f = isHorizontal ? [pos + lineOffset[0], origin + lineOffset[1]] : [origin + lineOffset[0], pos + lineOffset[1]],
            x1 = _f[0],
            y1 = _f[1];

        var _g = isHorizontal ? [x1, y1 + lineSize] : [x1 + lineSize, y1],
            x2 = _g[0],
            y2 = _g[1];

        context.moveTo(x1 + lineOffset[0], y1 + lineOffset[1]);
        context.lineTo(x2 + lineOffset[0], y2 + lineOffset[1]);
      }
    }

    context.stroke(); // Render Labels

    for (var i = 0; i <= length; ++i) {
      var value = i + minRange;

      if (!isNegative && value < 0) {
        continue;
      }

      var startValue = value * unit;
      var startPos = (startValue - scrollPos) * nextZoom;

      if (startPos < -zoomUnit || startPos >= size + unit * nextZoom || startValue < range[0] || startValue > range[1]) {
        continue;
      }

      var origin = 0;

      switch (direction) {
        case "start":
          origin = 17;
          break;

        case "center":
          origin = barSize / 2;
          break;

        case "end":
          origin = barSize - 17;
          break;
      }

      var _h = isHorizontal ? [startPos + alignOffset * -3, origin] : [origin, startPos + alignOffset * 3],
          startX = _h[0],
          startY = _h[1];

      var text = "".concat(startValue);

      if (textFormat) {
        text = textFormat(startValue);
      }

      context.textAlign = textAlign;
      var backgroundOffset = 0;
      var textSize = context.measureText(text).width;

      switch (textAlign) {
        case "left":
          backgroundOffset = 0;
          break;

        case "center":
          backgroundOffset = -textSize / 2;
          break;

        case "right":
          backgroundOffset = -textSize;
          break;
      }

      if (isHorizontal) {
        context.save();
        context.fillStyle = textBackgroundColor;
        context.fillRect(startX + textOffset[0] + backgroundOffset, 0, textSize, mainLineSize);
        context.restore();
      } else {
        context.save();
        context.translate(0, startY + textOffset[1]);
        context.rotate(-Math.PI / 2);
        context.fillStyle = textBackgroundColor;
        context.fillRect(backgroundOffset, 0, textSize, mainLineSize);
        context.restore();
      }

      if (isHorizontal) {
        context.fillText(text, startX + textOffset[0], startY + textOffset[1]);
      } else {
        context.save();
        context.translate(startX + textOffset[0], startY + textOffset[1]);
        context.rotate(-Math.PI / 2);
        context.fillText(text, 0, 0);
        context.restore();
      }
    }

    context.restore();
  };

  __proto._getRulerScale = function () {
    var defaultPixelScale = this.props.defaultPixelScale || 2;

    if (!this._rulerScale) {
      var isHighDensity = window.devicePixelRatio > 1;

      if (!isHighDensity && window.matchMedia) {
        var mq = window.matchMedia('only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen  and (min-device-pixel-ratio: 1.3), only screen and (min-resolution: 1.3dppx)');
        isHighDensity = mq && mq.matches;
      }

      this._rulerScale = isHighDensity ? 3 : defaultPixelScale;
    }

    return this._rulerScale;
  };

  Ruler.defaultProps = {
    type: "horizontal",
    zoom: 1,
    width: 0,
    height: 0,
    unit: 50,
    negativeRuler: true,
    mainLineSize: "100%",
    longLineSize: 10,
    shortLineSize: 7,
    segment: 10,
    direction: "end",
    style: {
      width: "100%",
      height: "100%"
    },
    backgroundColor: "#333333",
    font: "10px sans-serif",
    textColor: "#ffffff",
    textBackgroundColor: 'transparent',
    lineColor: "#777777",
    range: [-Infinity, Infinity],
    rangeBackgroundColor: 'transparent',
    lineWidth: 1,
    selectedBackgroundColor: "#555555"
  };
  return Ruler;
}(PureComponent);

var PROPERTIES = ["type", "width", "height", "unit", "zoom", "direction", "textAlign", "font", "segment", "mainLineSize", "longLineSize", "shortLineSize", "lineOffset", "textOffset", "negativeRuler", "range", "scrollPos", "style", "backgroundColor", "rangeBackgroundColor", "lineColor", "textColor", "textBackgroundColor", "textFormat", "portalContainer", "selectedBackgroundColor", "selectedRanges", "defaultPixelScale", "useResizeObserver"];
var METHODS = ["scroll", "resize", "getScrollPos"];

export default Ruler;
export { METHODS, PROPERTIES };
//# sourceMappingURL=ruler.esm.js.map
